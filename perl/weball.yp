%{
use v5.10;
use Data::Dumper;

use AST::Class;
use AST::FNCall;
use AST::GetMember;
use AST::Assign;
use AST::IsEqual;
use AST::Ident;
use AST::Return;
use AST::Primitive;

use AST::Math::Add;
use AST::Math::Divide;
use AST::Math::Multiply;
use AST::Math::Subtract;

my %classes = ();

my @focus  = ();

sub fpush {
	push @focus, @_
}

sub fpop {
	pop @focus
}

sub f :lvalue {
	$focus[$#focus]
}

%}

%left ','
%right '->'
%right '='
%nonassoc '=='
%left '-' '+'
%left '*' '/'
#%left NEG
#%right '^'

%left '.'


%%

start
	: lines
	|
	;

lines
	: lines outer_line {
		push(@{$_[1]}, $_[2][0]);
		$_[1];
	}
	| outer_line { $_[1]}
	;

outer_line
	: class_def { [$_[1]] }
	;

class_def
	: class_t ident_t {
		fpush(AST::Class->new($_[2]->value));
		
	} attribute_list_o '{' inner_lines_o '}' {
		
		return fpop;
	}
	;

inner_lines_o
	: inner_lines
	| # empty
	;

inner_lines
	: inner_lines inner_line
	| inner_line
	;

inner_line
	: var_decl ';' 
	| dbfunction_decl
	;

dbfunction_decl
	: dbfunction_t ident_t {fpush(AST::Class::DBFunction->new($_[2]->value))}
		'(' fn_decl_arg_list_o ')' attribute_list_o '{' code_inner_lines_o '}'{
			my $dbf = fpop();
			f()->addDBF($dbf);
		}
	;

code_inner_lines_o
	: #empty
	| code_inner_lines
	;

code_inner_lines
	: code_inner_lines code_inner_line {
		f()->addStmt($_[2]);
	}
	| code_inner_line {
		f()->addStmt($_[1]) if defined $_[1];
	}
	;

code_inner_line
	: var_decl ';' 
	| expr ';'
	| return_t expr ';' { AST::Return->new($_[2]) }
	;

expr
	: expr '->' expr { AST::GetMember->new(@_[1, 3]) }
	| binexpr
	| fncall
	| '(' expr ')'   { $_[2] }
	| arg
	;

binexpr
	: expr '='  expr { AST::Assign->new(@_[1, 3])  }
	| expr '==' expr { AST::IsEqual->new(@_[1, 3]) }
	| expr '+' expr  { AST::Math::Add->new(@_[1, 3]) }
	| expr '-' expr  { AST::Math::Subtract->new(@_[1, 3]) }
	| expr '/' expr  { AST::Math::Divide->new(@_[1, 3]) }
	| expr '*' expr  { AST::Math::Multiply->new(@_[1, 3]) }
	;

fncall
	: fq_ident {
		fpush(AST::FNCall->new($_[1]))
	} '(' fn_call_arg_list_o ')' {
		fpop
	}
	;
	
var_decl 
	: var_type ident_t {
		fpush(AST::Class::Var->new($_[2]->value, $_[1]))
		} 
		attribute_list_o var_decl_assign_o {
		my $var = fpop();
		f()->addVar($var);
		
		my $defAttr = AST::Class::Attr->new('default');
		
		if ($_[5]) {
			$defAttr->addArg($_[5]);
			$var->addAttr($defAttr);
		}
		undef
	}
	| var_type  local_ident_t {
		fpush(AST::Class::Var->new($_[2]->value, $_[1]))
		} 
		attribute_list_o  var_decl_assign_o {
		my $var = fpop();
		f()->addVar($var);
		
		my $defAttr = AST::Class::Attr->new('default');
		
		if ($_[5]) {
			$defAttr->addArg($_[5]);
			$var->addAttr($defAttr);
		}
		undef
	}
	;

var_type
	: int_t    { $_[1]->value }
	| uint_t   { $_[1]->value }
	| bool_t   { $_[1]->value }
	| string_t { $_[1]->value }
	| double_t { $_[1]->value }
	;

attribute_list_o
	: # null
	| attribute_list
	;

attribute_list
	: attribute_list attribute
	| attribute
	;

attribute
	: ':' ident_t {
			fpush(AST::Class::Attr->new($_[2]->value));
			
		} attribute_arg_list_o {
			my $attr = fpop;
			f()->addAttr($attr);
	}
	;

fn_decl_arg_list_o
	: fn_decl_arg_list
	| # no args
	;

fn_decl_arg_list
	: fn_decl_arg_list ',' fn_decl_arg {
		f()->addArg($_[3]);
	}
	| fn_decl_arg {
		f()->addArg($_[1]);
	}
	;

attribute_arg_list_o 
	: #null
	| '(' ')'
	| '(' arg_list ')'
	;

fn_call_arg_list_o
	: fn_call_arg_list
	| #no args
	;

fn_call_arg_list
	: fn_call_arg_list ',' fn_call_arg {
		f()->addArg($_[3])
	}
	| fn_call_arg {
		f()->addArg($_[1])
	}
	;

fn_call_arg
	: expr
	;

arg_list
	: arg_list ',' arg {
		f()->addArg($_[3]);
	}
	| arg {
		f()->addArg($_[1]);
	}
	;

var_decl_assign_o 
	: #null
	| var_decl_assign
	;

var_decl_assign
	: '=' expr { $_[2] }
	;

fn_decl_arg
	: var_decl
	;
	
arg
	: fq_ident
	| local_ident_t { AST::Ident->new($_[1], 1) }
	| number_t      { AST::Primitive->new('number', $_[1]) }
	| true_t        { AST::Primitive->new('bool', $_[1]) }
	| false_t       { AST::Primitive->new('bool', $_[1]) }
	| string_t      { AST::Primitive->new('string', $_[1]) }
	;

fq_ident
	: ident_t { AST::Ident->new($_[1]) }
	| fq_ident '.' ident_t {
		if (ref $_[1] eq 'AST::Ident') {
			return $_[1]->addPart(AST::Ident->new($_[3]));
		}
		else {
			die "Shouldn't get here";
		}
		
	}
	
	;
	

%%
